* About
This is a toy example that reproduces a potential memory leak in SBCL.
* Symptoms
The problem occurs when using FFI to invoke a callback from a C library on another thread.

Whenever the C library invokes a lisp callback on a foreign thread, a little bit of off-heap memory seems to leak.
I can't see this in lisp (using the room function), but htop shows the process memory growing. The leak is very small, but the memory is never reclaimed.

If I regularly invoke the callback lisp will quickly run out of memory and drop into ldb.

#+BEGIN_SRC shell
fatal error encountered in SBCL pid 4955(tid 140737321719552):
An mprotect call failed with ENOMEM. This probably means that the maximum amount
of separate memory mappings was exceeded. To fix the problem, either increase
the maximum with e.g. 'echo 262144 > /proc/sys/vm/max_map_count' or recompile
SBCL with a larger value for GENCGC-CARD-BYTES in
'src/compiler/target/backend-parms.lisp'.

Welcome to LDB, a low-level debugger for the Lisp runtime environment.
ldb>
#+END_SRC

* Additional information
System: 64 bit arch linux

sbcl version: 1.3.14
* Reason to suspect SBCL
The leak only occurs when the main thread is lisp. The equivalent C program does not leak.
* Running the example
To build and run the example:
#+BEGIN_SRC shell
make run
#+END_SRC
* Run the example without lisp
To run an equivalent program using only C:
#+BEGIN_SRC shell
make run-c
#+END_SRC
